// post process 1.gs
/**
 * Utility: return unique array preserving order
 */
function ensureUniqueArray(arr) {
  const seen = new Set();
  const out = [];
  for (const x of (arr || [])) {
    if (!seen.has(x)) { seen.add(x); out.push(x); }
  }
  return out;
}

/**
 * Parse a resolved URL to discover site (SB / SV / QQ) and post id if present.
 * Returns { source: 'SB'|'SV'|'QQ', id: '12345', link: '<url>' } or null if can't parse.
 *
 * Handles:
 *  - thread URLs with #post-<id>
 *  - thread URLs where post id may appear as ".<id>" (e.g. slug.33904)
 *  - thread URLs where post id may appear as "/<id>/"
 *  - direct posts (/posts/<id>/)
 */
function parseResolvedUrl(url) {
  if (!url || typeof url !== 'string') return null;
  const u = url.trim();
  const lower = u.toLowerCase();

  // determine source by domain
  let source = null;
  if (lower.indexOf('spacebattles.com') !== -1) source = 'SB';
  else if (lower.indexOf('sufficientvelocity.com') !== -1) source = 'SV';
  else if (lower.indexOf('questionablequesting.com') !== -1) source = 'QQ';
  else return null; // unknown site — do not promote

  // patterns for post / thread id extraction
  const patterns = [
    /#post-(\d{5,12})/i,                       // anchor style #post-114016169
    /\/posts\/(\d{5,12})(?:\/|$)/i,            // direct /posts/12345/ style
    /post-(\d{5,12})/i,                        // fallback 'post-12345' somewhere
    /(?:\.|\/)(\d{5,12})(?:\/|$)/i             // dot or slash then digits (handles slug.33904 and /12345/)
  ];

  for (const p of patterns) {
    const m = u.match(p);
    if (m && m[1]) {
      return { source, id: String(m[1]), link: u };
    }
  }

  // couldn't extract an id — return minimal info (will not match extracted SV lines by id)
  return { source, id: '', link: u };
}

/**
 * Normalize RESOLVED / thread urls in a block of text:
 * - remove /page-\d+ segments
 * - remove #post-\d+ anchors
 * - normalize thread URL forms like:
 *     /threads/<slug>.<id>/...  -> /threads/<slug>.<id>/
 *     /threads/<slug>/<id>/...  -> /threads/<slug>.<id>/
 *   so the thread ID is preserved and trailing slash present.
 * - normalise /posts/<id>/ to canonical trailing slash
 *
 * Returns normalized text.
 */
function normalizeResolvedAndThreadUrls(text) {
  if (!text || typeof text !== 'string') return text;

  // 1) Remove /page-N segments and #post-N anchors globally
  text = text.replace(/\/page-\d+(?=\/|#|$)/gi, '');
  text = text.replace(/#post-\d+/gi, '');

  // 2) Normalize /threads/<slug>.<id>(/anything)?  -> /threads/<slug>.<id>/
  //     handles both dot and slash separators for the id
  text = text.replace(
    /((?:https?:\/\/)[^\s'"]+?\/threads\/([^\/\s'"]+?))(?:(?:\.|\/)(\d{4,12}))(?:\/[^\s'"]*)?/gi,
    // capture entire base + ensure slash after id
    function(_, baseWithSlug, slugPart, idPart) {
      // baseWithSlug currently ends with /threads/<slug> or includes .<id> depending on input,
      // rebuild canonical form as: <base>/threads/<slug>.<id>/
      // Make sure we don't accidentally duplicate a trailing slash.
      const canonical = baseWithSlug.replace(/\/+$/,'') + '.' + idPart + '/';
      return canonical;
    }
  );

  // 3) Normalize any /threads/.../<id>/ (slash style) -> collapse into slug.id/
  text = text.replace(
    /((?:https?:\/\/)[^\s'"]+?\/threads\/([^\/\s'"]+?)\/)(\d{4,12})(?:\/[^\s'"]*)?/gi,
    function(_, baseWithSlug, slugPart, idPart) {
      const canonical = baseWithSlug.replace(/\/threads\/.+?\/$/i, '/threads/' + slugPart + '.') + idPart + '/';
      return canonical;
    }
  );

  // 4) Normalize /posts/<id>/ to ensure trailing slash
  text = text.replace(/(https?:\/\/[^\s'"]+\/posts\/(\d{4,12}))(?:\/[^\s'"]*)?/gi, '$1/');

  // 5) Collapse multiple slashes at the end to a single slash
  text = text.replace(/\/{2,}/g, '/');

  return text;
}

/**
 * Post-process main Drive file to:
 *  - deduplicate raw RESOLVED lines
 *  - parse and promote resolved forum entries to top block as "RESOLVED - <SRC> | <url>"
 *  - keep AO3/FF top entries (lines matching "<SRC> | <id> | <link>")
 *  - build SV/SB/QQ summary and unresolved list annotated with Resolved/Unresolved
 *  - preserve deduped raw RESOLVED lines at bottom for audit
 */
function postProcessMainFile() {
  try {
    Logger.log(">>> postProcessMainFile: entered");

    const mainFile = getOrCreateDriveFile(DRIVE_FILENAME_MAIN);
    Logger.log("Got mainFile handle");

    let mainText = '';
    try {
      mainText = mainFile.getBlob().getDataAsString();
      Logger.log("Fetched mainText, length=" + mainText.length);
    } catch (e) {
      Logger.log("Failed to read mainFile: " + e);
      mainText = '';
    }

    // Accept source tokens 2-5 chars (letters/numbers), and allow non-numeric ids (safer).
    const topEntryRegex = /^\s*([A-Z0-9]{2,5})\s*\|\s*([^\|]+?)\s*\|\s*(\S.*)$/i;
    const topEntries = [];
    const otherLines = [];
    const lines = mainText.split(/\r?\n/);
    const rawResolvedLines = [];

    Logger.log("Processing lines: count=" + lines.length);

    for (const ln of lines) {
      const mres = ln.match(/^\s*RESOLVED\s*\|\s*(\S.*)$/i);
      if (mres && mres[1]) {
        // preserve raw resolved line exactly as-is (trim only)
        rawResolvedLines.push(mres[1].trim());
        continue;
      }
      const mt = ln.match(topEntryRegex);
      if (mt) {
        const source = String(mt[1]).toUpperCase().trim();
        const id = String(mt[2]).trim();
        const link = String(mt[3]).trim();
        topEntries.push({ source, id, link });
        continue;
      }
      if (ln && ln.trim()) otherLines.push(ln);
    }
    Logger.log("rawResolvedLines=" + rawResolvedLines.length + ", topEntries=" + topEntries.length + ", otherLines=" + otherLines.length);

    // dedupe raw resolved lines preserving order (exact-string duplicates only)
    const dedupResolvedRaw = ensureUniqueArray(rawResolvedLines);
    Logger.log("Deduped resolved lines (exact):=" + dedupResolvedRaw.length);

    // Helper: parse resolved raw into canonical thread info (same as before)
    function parseResolvedToCanonical(raw) {
      if (!raw || typeof raw !== 'string') return null;
      const u = raw.trim();

      // determine source/domain
      let source = null;
      if (/forums\.spacebattles\.com/i.test(u)) source = 'SB';
      else if (/forums\.sufficientvelocity\.com/i.test(u)) source = 'SV';
      else if (/forum\.questionablequesting\.com/i.test(u)) source = 'QQ';
      else return null; // not a forum we handle here

      // Attempt to extract thread id (slug.id) or posts/<id>
      // 1) thread with .<id> (slug.12345)
      let m = u.match(/\/threads\/([^\/\s'"]+?)(?:[\/#?]|$)/i);
      if (m && m[1]) {
        const slugPart = m[1];
        // if slugPart contains a dot followed by digits, extract id
        const dotMatch = slugPart.match(/(?:^|\.)(\d{3,12})$/);
        if (dotMatch && dotMatch[1]) {
          const id = dotMatch[1];
          const hostMatch = u.match(/^(https?:\/\/[^\/]+)\/threads\//i);
          const base = hostMatch ? hostMatch[1] : ('https://' + u.split('/')[2]);
          const canonical = `${base}/threads/${slugPart.replace(/\.\d+$/,'')}.${id}/`;
          return { source, id: String(id), canonical };
        }
        // else maybe the id appears later as /threads/slug/<id> style
        const slashIdMatch = u.match(/\/threads\/[^\/\s'"]+\/(\d{3,12})(?:[\/#?]|$)/i);
        if (slashIdMatch && slashIdMatch[1]) {
          const id = slashIdMatch[1];
          const slugOnly = slugPart;
          const hostMatch = u.match(/^(https?:\/\/[^\/]+)\/threads\//i);
          const base = hostMatch ? hostMatch[1] : ('https://' + u.split('/')[2]);
          const canonical = `${base}/threads/${slugOnly}.${id}/`;
          return { source, id: String(id), canonical };
        }
      }

      // 2) direct /posts/<id>/ style
      m = u.match(/\/posts\/(\d{3,12})(?:\/|$)/i);
      if (m && m[1]) {
        const id = m[1];
        const hostMatch = u.match(/^(https?:\/\/[^\/]+)\//i);
        const base = hostMatch ? hostMatch[1] : ('https://' + u.split('/')[2]);
        const canonical = `${base}/posts/${id}/`;
        return { source, id: String(id), canonical };
      }

      // fallback: try to find any numeric block of 5-12 digits that looks like an id
      const fallback = u.match(/(\d{5,12})/);
      if (fallback && fallback[1]) {
        const id = fallback[1];
        const hostMatch = u.match(/^(https?:\/\/[^\/]+)\/threads\//i) || u.match(/^(https?:\/\/[^\/]+)\//i);
        const base = hostMatch ? hostMatch[1] : ('https://' + u.split('/')[2]);
        if (/\/posts\//i.test(u)) {
          return { source, id: String(id), canonical: `${base}/posts/${id}/` };
        } else {
          return { source, id: String(id), canonical: `${base}/threads/.${id}/` };
        }
      }

      return null;
    }

    // Build a set of resolved post IDs (source-postId) from raw resolved lines
    const resolvedPostIdSet = new Set();
    for (const raw of dedupResolvedRaw) {
      try {
        // detect source
        let src = null;
        if (/forums\.spacebattles\.com/i.test(raw)) src = 'SB';
        else if (/forums\.sufficientvelocity\.com/i.test(raw)) src = 'SV';
        else if (/forum\.questionablequesting\.com/i.test(raw)) src = 'QQ';

        if (!src) continue;

        // find any post-id patterns: #post-12345, post-12345, /posts/12345/
        let m;
        const patterns = [/#[pP]ost-(\d{3,12})/g, /post-(\d{3,12})/g, /\/posts\/(\d{3,12})(?:\/|$)/g];
        for (const p of patterns) {
          while ((m = p.exec(raw)) !== null) {
            if (m && m[1]) resolvedPostIdSet.add(`${src}-${m[1]}`);
          }
        }
      } catch (e) {
        // non-fatal
      }
    }
    Logger.log("Resolved post-id set built, count=" + resolvedPostIdSet.size);

    // Parse dedupResolvedRaw into parsedResolved but dedupe by thread id/source (so multiple raw lines for same thread => one promoted entry)
    const parsedResolved = [];
    const resolvedKeySet = new Set();
    for (const raw of dedupResolvedRaw) {
      const parsed = parseResolvedToCanonical(raw);
      if (parsed && parsed.source) {
        const key = parsed.id ? `${parsed.source}-${parsed.id}` : `${parsed.source}-${(parsed.canonical||raw).replace(/\/+$/,'')}`;
        if (!resolvedKeySet.has(key)) {
          parsedResolved.push({ source: parsed.source, id: parsed.id || '', link: parsed.canonical || raw });
          resolvedKeySet.add(key);
        }
      }
    }
    Logger.log("Parsed resolved entries (thread-canonical, deduped)=" + parsedResolved.length);

    // Build topMap keyed by source-id (or source-link for non-id)
    const topMap = new Map();
    for (const e of topEntries) {
      const k = e.id ? `${e.source}-${e.id}` : `${e.source}-${e.link.replace(/\/+$/,'')}`;
      if (!topMap.has(k)) topMap.set(k, e);
    }
    Logger.log("TopMap initialized, size=" + topMap.size);

    // Merge resolved entries into topMap (promote resolved forum threads)
    for (const p of parsedResolved) {
      const key = p.id ? `${p.source}-${p.id}` : `${p.source}-${p.link.replace(/\/+$/,'')}`;
      if (!topMap.has(key)) {
        topMap.set(key, { source: p.source, id: p.id || '', link: p.link, resolvedPromoted: true });
      } else {
        const existing = topMap.get(key);
        if (existing && (!existing.link || existing.link.indexOf('http') !== 0)) {
          existing.link = p.link;
          existing.resolvedPromoted = true;
          topMap.set(key, existing);
        }
      }
    }
    Logger.log("TopMap after merging resolved, size=" + topMap.size);

    // Build 'others' : non-forum entries (FF, AO3, etc.)
    const others = Array.from(topMap.values()).filter(x => !['SV','SB','QQ'].includes(x.source));
    others.sort((a,b) => {
      if (a.source === b.source) return String(a.id || '').localeCompare(String(b.id || ''));
      return a.source.localeCompare(b.source);
    });
    Logger.log("Others built, count=" + others.length);

    // Build promoted resolved text lines for top block (one per thread)
    const promotedResolved = [];
    for (const p of parsedResolved) {
      promotedResolved.push({ source: p.source, id: p.id, link: p.link, text: `RESOLVED - ${p.source} | ${p.link}` });
    }
    Logger.log("PromotedResolved built, count=" + promotedResolved.length);

    // Build top block lines: others first (FF/AO3/... ), then promoted resolved entries
    const topBlockLines = [];
    for (const o of others) topBlockLines.push(`${o.source} | ${o.id} | ${o.link}`);
    for (const pr of promotedResolved) topBlockLines.push(pr.text);
    Logger.log("TopBlockLines built, count=" + topBlockLines.length);

    // Build the svLines list (list of all SV/SB/QQ links) either from the sv file or from topMap/otherLines fallback
    let svFileText = '';
    try {
      const svf = getOrCreateDriveFile(DRIVE_FILENAME_SVSBQQ);
      svFileText = svf.getBlob().getDataAsString();
      Logger.log("Read svFileText, length=" + svFileText.length);
    } catch (e) {
      Logger.log("Failed to read svFileText: " + e);
      svFileText = '';
    }

    let svLines = [];
    if (svFileText && svFileText.trim()) {
      svLines = svFileText.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      Logger.log("svLines loaded from file, count=" + svLines.length);
    } else {
      for (const v of topMap.values()) {
        if (['SV','SB','QQ'].includes(v.source)) svLines.push(v.link);
      }
      const R = /https?:\/\/(?:www\.)?(?:forums?\.(?:sufficientvelocity|spacebattles)\.com|forum\.questionablequesting\.com)\/[^\s'"]+/ig;
      for (const ln of otherLines) {
        let m;
        while ((m = R.exec(ln)) !== null) svLines.push(m[0]);
      }
      svLines = ensureUniqueArray(svLines);
      Logger.log("svLines built from fallback, count=" + svLines.length);
    }

    // Annotate SV lines as Resolved / Unresolved using thread-id OR post-id matches
    const unresolvedAnnotated = [];
    let detectedResolvedCount = 0;
    for (const sv of svLines) {
      // parse for thread canonical info
      const parsed = parseResolvedToCanonical(sv) || {};
      const threadKey = (parsed.source ? parsed.source : '') + '-' + (parsed.id ? parsed.id : (parsed.canonical ? parsed.canonical.replace(/\/+$/,'') : sv.replace(/\/+$/,'')));

      // attempt to extract a post-id from the sv line (e.g. /posts/12345/ or #post-12345 or post-12345)
      let postId = null;
      let mpost;
      mpost = sv.match(/\/posts\/(\d{3,12})(?:\/|$)/i) || sv.match(/#post-(\d{3,12})/i) || sv.match(/post-(\d{3,12})/i);
      if (mpost && mpost[1]) postId = mpost[1];

      // determine resolution: either thread-level present in resolvedKeys OR post-level present in resolvedPostIdSet
      let isResolved = false;
      if (threadKey && resolvedKeySet.has(threadKey)) isResolved = true;
      else if (parsed.source && postId && resolvedPostIdSet.has(`${parsed.source}-${postId}`)) isResolved = true;
      else {
        // if parsed.source is empty, attempt to detect source via hostname match
        if (!isResolved && postId) {
          let detectedSource = null;
          if (/forums\.spacebattles\.com/i.test(sv)) detectedSource = 'SB';
          else if (/forums\.sufficientvelocity\.com/i.test(sv)) detectedSource = 'SV';
          else if (/forum\.questionablequesting\.com/i.test(sv)) detectedSource = 'QQ';
          if (detectedSource && resolvedPostIdSet.has(`${detectedSource}-${postId}`)) isResolved = true;
        }
      }

      unresolvedAnnotated.push(`${sv}  - ${isResolved ? 'Resolved' : 'Unresolved'}`);
      if (isResolved) detectedResolvedCount++;
    }

    const totalSV = svLines.length;
    const unresolvedCount = totalSV - detectedResolvedCount;
    Logger.log(`Summary counts: totalSV=${totalSV}, resolved=${detectedResolvedCount}, unresolved=${unresolvedCount}`);

    const sep = '\n\n----- SV/SB/QQ SUMMARY -----\n';
    const summaryLines = [
      `Total SV/SB/QQ links: ${totalSV}`,
      `Resolved (detected): ${detectedResolvedCount}`,
      `Unresolved: ${unresolvedCount}`,
      ''
    ].join('\n');

    const unresolvedSection = 'Unresolved links:\n' + (unresolvedAnnotated.length ? unresolvedAnnotated.join('\n') : 'None') + '\n\n';
    const resolvedRawHeader = 'Previously RESOLVED lines found (raw):\n';
    // Use dedupResolvedRaw (exact-string dedupe) and preserve original formatting/anchors
    const resolvedRawSection = resolvedRawHeader + (dedupResolvedRaw.length ? dedupResolvedRaw.join('\n') : 'None') + '\n';

    // ----------------- FINISHED LINK COUNTS (unchanged) -----------------
    const finishedCounts = {};
    let finishedTotal = 0;
    for (const o of others) {
      if (!o || !o.source) continue;
      finishedCounts[o.source] = (finishedCounts[o.source] || 0) + 1;
      finishedTotal++;
    }
    for (const pr of promotedResolved) {
      if (!pr || !pr.source) continue;
      finishedCounts[pr.source] = (finishedCounts[pr.source] || 0) + 1;
      finishedTotal++;
    }
    const sourceKeys = Object.keys(finishedCounts).sort();
    const countLines = [];
    countLines.push(`Total finished links: ${finishedTotal}`);
    for (const k of sourceKeys) countLines.push(`${k}: ${finishedCounts[k]}`);
    const countsBlock = '\n----- FINISHED LINK COUNTS -----\n' + (countLines.length ? (countLines.join('\n') + '\n\n') : '\n');
    // -------------------------------------------------------------------

    const finalContent = (topBlockLines.length ? (topBlockLines.join('\n') + '\n') : '') + countsBlock + sep + summaryLines + unresolvedSection + resolvedRawSection;

    // Write back final content (no global page/post stripping)
    Logger.log("Final content length (prepared)=" + finalContent.length);
    mainFile.setContent(finalContent);
    Logger.log("mainFile updated successfully");

    return true;
  } catch (err) {
    Logger.log('postProcessMainFile error: ' + (err && err.stack ? err.stack : err));
    return false;
  }
}