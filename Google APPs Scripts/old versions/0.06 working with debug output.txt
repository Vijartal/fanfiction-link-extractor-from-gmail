/*
 * Google Apps Script: Extract FanFiction.net Story Links from Gmail and Label Threads
 * Uses simple top-level Gmail labels (auto-creates if missing), with debug logs for label operations.
 * Source label: 'z-link-to-extract'
 * Processed label: 'z-link-extracted'
 * Stores extracted links in a Drive text file called "FF links extracted from gmail.txt" and labels threads as processed.
 * Deduplicates based on story ID by checking against existing entries in the file.
 * Only labels threads that actually contain new links, leaving others untouched.
 *
 * Setup:
 * 1. No need to manually create labels; the script will create SOURCE and PROCESSED labels if absent.
 * 2. Deploy this script in script.google.com and grant Gmail and Drive permissions.
 * 3. Use Edit > Current project's triggers to run `extractFanfictionLinks` on a time-driven schedule.
 */

const SOURCE_LABEL_NAME = 'z link to extract';
const PROCESSED_LABEL_NAME = 'z link extracted';
const DRIVE_FILENAME = 'FF links extracted from gmail.txt';

function extractFanfictionLinks() {
  // DEBUG: List all existing labels
  const allLabels = GmailApp.getUserLabels().map(lbl => lbl.getName());
  Logger.log('All Gmail labels: ' + JSON.stringify(allLabels));

  // 1. Auto-create or fetch source label
  let sourceLabel = GmailApp.getUserLabelByName(SOURCE_LABEL_NAME);
  if (sourceLabel) {
    Logger.log('Found existing source label: ' + sourceLabel.getName());
  } else {
    try {
      sourceLabel = GmailApp.createLabel(SOURCE_LABEL_NAME);
      Logger.log('Created new source label: ' + sourceLabel.getName());
    } catch (e) {
      Logger.log('Error creating source label: ' + e.message);
      return;
    }
  }

  // 2. Auto-create or fetch processed label
  let processedLabel = GmailApp.getUserLabelByName(PROCESSED_LABEL_NAME);
  if (processedLabel) {
    Logger.log('Found existing processed label: ' + processedLabel.getName());
  } else {
    try {
      processedLabel = GmailApp.createLabel(PROCESSED_LABEL_NAME);
      Logger.log('Created new processed label: ' + processedLabel.getName());
    } catch (e) {
      Logger.log('Error creating processed label: ' + e.message);
      return;
    }
  }

  // Prepare Drive file (create if missing)
  let fileIterator = DriveApp.getFilesByName(DRIVE_FILENAME);
  let file = fileIterator.hasNext() ? fileIterator.next() : DriveApp.createFile(DRIVE_FILENAME, '');
  let existingContent = file.getBlob().getDataAsString();

  // Build set of extracted story IDs
  const existingIds = new Set();
  existingContent.split('\n').forEach(line => {
    const parts = line.split('|').map(s => s.trim());
    if (parts[0] && /^\d+$/.test(parts[0])) existingIds.add(parts[0]);
  });

  let newContent = '';
  let linksAddedTotal = 0;
  let threadsProcessed = 0;

  // Regex to match FanFiction.net story links
  const linkRegex = /https?:\/\/(?:www\.)?fanfiction\.net\/s\/(\d{1,8})(?:\/\d+)?(?:\/[^\/\s"'<>]+)?/gi;

  // Fetch threads with the source label
  const threads = sourceLabel.getThreads();
  Logger.log('Threads found with source label: ' + threads.length);

  threads.forEach(thread => {
    let newLinksInThread = 0;
    thread.getMessages().forEach(msg => {
      const body = msg.getBody();
      let match;
      while ((match = linkRegex.exec(body)) !== null) {
        const storyId = match[1];
        const url = match[0].replace(/['"<>]+$/, '');
        if (!existingIds.has(storyId)) {
          newContent += `${storyId}  |  ${url}\n`;
          existingIds.add(storyId);
          newLinksInThread++;
        }
      }
    });

    if (newLinksInThread > 0) {
      thread.addLabel(processedLabel);
      thread.removeLabel(sourceLabel);
      threadsProcessed++;
      linksAddedTotal += newLinksInThread;
      Logger.log(`Thread ${thread.getId()} processed with ${newLinksInThread} new link(s).`);
    } else {
      Logger.log(`Thread ${thread.getId()} skipped (no new links).`);
    }
  });

  // Append new links to the Drive file
  if (linksAddedTotal > 0) {
    file.setContent(existingContent + newContent);
    Logger.log(`Appended ${linksAddedTotal} new link(s) to ${DRIVE_FILENAME}.`);
  } else {
    Logger.log('No new unique story IDs found to append.');
  }
  Logger.log(`Extraction complete. Processed ${threadsProcessed} thread(s).`);
}
