/*
 * Google Apps Script: Extract FanFiction.net & AO3 Story Links from Gmail and Label Threads
 * Supports nested Gmail labels (e.g. 'Parent/Sub') for source and processed labels.
 * Debug logs show label resolution and thread counts.
 * Stores extracted links in a Drive text file called "FF links extracted from gmail.txt" and labels threads as processed.
 * Deduplicates based on story ID+source by checking against existing entries in the file.
 * Only labels threads that contain new links, leaving others untouched.
 *
 * Setup:
 * 1. Define SOURCE_LABEL_NAME (e.g. 'Fanfiction/to-extract').
 * 2. Define PROCESSED_LABEL_NAME (e.g. 'Fanfiction/extracted').
 * 3. Deploy in script.google.com with Gmail and Drive scopes.
 * 4. Trigger `extractFanfictionLinks` on a schedule.
 */

const SOURCE_LABEL_NAME    = 'fanfiction to download/z link to extract';
const PROCESSED_LABEL_NAME = 'fanfiction to download/z link extracted';
const DRIVE_FILENAME       = 'FF links extracted from gmail.txt';

function extractFanfictionLinks() {
  // DEBUG: list all labels
  const allLabels = GmailApp.getUserLabels().map(lbl => lbl.getName());
  Logger.log('All labels: ' + JSON.stringify(allLabels));

  // 1. Collect source labels (exact + sublabels)
  const sourceLabels = [];
  const exact = GmailApp.getUserLabelByName(SOURCE_LABEL_NAME);
  if (exact) sourceLabels.push(exact);
  const prefix = SOURCE_LABEL_NAME + '/';
  GmailApp.getUserLabels().forEach(lbl => {
    if (lbl.getName().indexOf(prefix) === 0) sourceLabels.push(lbl);
  });
  if (sourceLabels.length === 0) {
    Logger.log(`No source label matching '${SOURCE_LABEL_NAME}' or sublabels.`);
    return;
  }
  Logger.log('Using source labels: ' + sourceLabels.map(l=>l.getName()).join(', '));

  // 2. Processed label
  const processedLabel = GmailApp.getUserLabelByName(PROCESSED_LABEL_NAME)
                         || GmailApp.createLabel(PROCESSED_LABEL_NAME);
  Logger.log('Processed label: ' + processedLabel.getName());

  // 3. Prepare Drive file
  const file = DriveApp.getFilesByName(DRIVE_FILENAME).hasNext()
               ? DriveApp.getFilesByName(DRIVE_FILENAME).next()
               : DriveApp.createFile(DRIVE_FILENAME, '');
  let existingContent = file.getBlob().getDataAsString();

  // 4. Build set of existing keys (domain:id)
  const existingKeys = new Set();
  existingContent.split('\n').forEach(line => {
    const parts = line.split('|').map(s=>s.trim());
    if (parts[0] && parts[1]) existingKeys.add(parts[0] + ':' + parts[1]);
  });

  let newContent = '';
  let totalAdded = 0;
  let processedThreads = 0;

  // 5. Regex patterns
  const ffRegex  = /https?:\/\/(?:www\.)?fanfiction\.net\/s\/(\d{1,8})(?:\/\d+)?(?:\/[^\/\s"'<>]+)?/gi;
  const ao3Regex = /https?:\/\/(?:www\.)?archiveofourown\.org\/works\/(\d{1,8})(?:\/chapters\/\d+)?/gi;

  // 6. Aggregate threads
  const threadMap = new Map();
  sourceLabels.forEach(lbl => lbl.getThreads().forEach(thr=>threadMap.set(thr.getId(),thr)));
  const threads = Array.from(threadMap.values());
  Logger.log('Threads to process: ' + threads.length);

  // 7. Process each thread
  threads.forEach(thread => {
    let addedThis = 0;
    thread.getMessages().forEach(msg => {
      const body = msg.getBody();
      let match;
      // FanFiction.net
      while ((match = ffRegex.exec(body)) !== null) {
        const id = match[1];
        const url = match[0].replace(/['"<>]+$/, '');
        const key = 'FF:' + id;
        if (!existingKeys.has(key)) {
          newContent += `FF | ${id} | ${url}\n`;
          existingKeys.add(key);
          addedThis++;
        }
      }
      // AO3
      while ((match = ao3Regex.exec(body)) !== null) {
        const id = match[1];
        const url = match[0];
        const key = 'AO3:' + id;
        if (!existingKeys.has(key)) {
          newContent += `AO3 | ${id} | ${url}\n`;
          existingKeys.add(key);
          addedThis++;
        }
      }
    });
    if (addedThis > 0) {
      thread.addLabel(processedLabel);
      sourceLabels.forEach(lbl=>thread.removeLabel(lbl));
      totalAdded += addedThis;
      processedThreads++;
      Logger.log(`Thread ${thread.getId()} added ${addedThis} link(s).`);
    } else {
      Logger.log(`Thread ${thread.getId()} no new links.`);
    }
  });

  // 8. Save new links
  if (totalAdded > 0) {
    file.setContent(existingContent + newContent);
    Logger.log(`Appended ${totalAdded} link(s) to ${DRIVE_FILENAME}`);
  } else {
    Logger.log('No new links found.');
  }
  Logger.log(`Done. Threads processed: ${processedThreads}`);
}
